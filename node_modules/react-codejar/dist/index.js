var React = require('react');
var codejar = require('codejar');
var linenumbers = require('codejar/linenumbers');

var getCaretOffset = function getCaretOffset(element) {
  var caretOffset = 0;
  var doc = element.ownerDocument || element.document;
  var win = doc.defaultView || doc.parentWindow;
  var sel;

  if (typeof win.getSelection != "undefined") {
    sel = win.getSelection();

    if (sel.rangeCount > 0) {
      var range = win.getSelection().getRangeAt(0);
      var preCaretRange = range.cloneRange();
      preCaretRange.selectNodeContents(element);
      preCaretRange.setEnd(range.endContainer, range.endOffset);
      caretOffset = preCaretRange.toString().length;
    }
  } else if ((sel = doc.selection) && sel.type != "Control") {
    var textRange = sel.createRange();
    var preCaretTextRange = doc.body.createTextRange();
    preCaretTextRange.moveToElementText(element);
    preCaretTextRange.setEndPoint("EndToEnd", textRange);
    caretOffset = preCaretTextRange.text.length;
  }

  return caretOffset;
};

var createRange = function createRange(el, chars, range) {
  if (!range) {
    range = document.createRange();
    range.selectNode(el);
    range.setStart(el, 0);
  }

  if (chars.count === 0) {
    range.setEnd(el, chars.count);
  } else if (el && chars.count > 0) {
    if (el.nodeType === Node.TEXT_NODE) {
      if (el.textContent.length < chars.count) {
        chars.count -= el.textContent.length;
      } else {
        range.setEnd(el, chars.count);
        chars.count = 0;
      }
    } else {
      for (var i = 0; i < el.childNodes.length; i++) {
        range = createRange(el.childNodes[i], chars, range);

        if (chars.count === 0) {
          break;
        }
      }
    }
  }

  return range;
};

var setCurrentCursorPosition = function setCurrentCursorPosition(el, chars) {
  if (chars >= 0) {
    var selection = window.getSelection();
    var range = createRange(el, {
      count: chars
    });

    if (range) {
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }
};

var useCodeJar = function useCodeJar(props) {
  var editorRef = React.useRef(null);
  var jar = React.useRef(null);

  var _React$useState = React.useState(0),
      cursorOffset = _React$useState[0],
      setCursorOffset = _React$useState[1];

  React.useEffect(function () {
    if (!editorRef.current) return;
    var highlight = props.lineNumbers ? linenumbers.withLineNumbers(props.highlight) : props.highlight;
    jar.current = codejar.CodeJar(editorRef.current, highlight, props.options);
    jar.current.updateCode(props.code);
    jar.current.onUpdate(function (txt) {
      if (!editorRef.current) return;
      setCursorOffset(getCaretOffset(editorRef.current));
      props.onUpdate(txt);
    });
    return function () {
      return jar.current.destroy();
    };
  }, []);
  React.useEffect(function () {
    if (!jar.current || !editorRef.current) return;
    jar.current.updateCode(props.code);
    setCurrentCursorPosition(editorRef.current, cursorOffset);
  }, [props.code]);
  React.useEffect(function () {
    if (!jar.current || !props.options) return;
    jar.current.updateOptions(props.options);
  }, [props.options]);
  return editorRef;
};
var ReactCodeJar = function ReactCodeJar(props) {
  var editorRef = useCodeJar(props);
  return React.createElement("div", {
    style: props.style,
    ref: editorRef
  });
};

exports.ReactCodeJar = ReactCodeJar;
exports.useCodeJar = useCodeJar;
//# sourceMappingURL=index.js.map
